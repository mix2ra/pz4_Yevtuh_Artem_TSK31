**<h2>ПЗ-4 Євтух Артем ЦК-31<h2>**
___
*Тема: Масиви*
___
*Хід роботи:*
1. Повторити теоретичні відомості
2. Виконати три завдання з таблиці 2 відповідно до свого варіанту у таблиці 1.
- В одному з завдань обов’язково має бути використаний цикл «for»
- В одному з завдань обов’язково має бути використаний цикл «for-each»
- Кожне завдання має бути реалізовано як окремий клас.
- Кожен клас має складатись щонайменше з двох методів:
- public static void main(String[] agrs) - точка входу. Містить код, що кілька разів
знаходить результат завдання при різних значеннях аргументів та параметрів. Для
перевірки мають бути присутні як дозволені так і заборонені комбінації аргументів та
параметрів.
- Метод, що реалізує задане завдання. Метод має перевіряти аргументи та у разі їх
помилковості аварійно закінчувати свою роботу шляхом викидання стандартного
виключення IllegalArgumentException, NullPointerException або
IndexOutOfBoundsException(дивись л/р №3).В жодному разі цей метод не повинен
напряму взаємодіяти з користувачем через консоль або інший UI (ніколи не змішуйте
бізнес-логіку та користувацький інтерфейс).
- Клас може містити інші допоміжні методи.
3. Відповісти на контрольні питання
___

Варіант №5.

*Вирази №5, №35, №65.*
___

Код виконання завдання у папці src.

___

***№1. Чим змінна відрізняється від масиву?***

Змінна зберігає одне значення певного типу.

Масив — це набір змінних одного типу, до яких можна звертатися за індексом.
Приклад:
` ` `
int x = 5;              // звичайна змінна
int[] arr = {1, 2, 3};  // масив із трьох елементів
` ` `


---



***№2. Що таке стек? Що таке купа? Яка між ними різниця?***

Стек (Stack) — ділянка пам’яті, де зберігаються локальні змінні та виклики методів.

Купа (Heap) — область пам’яті, де зберігаються об’єкти та масиви, створені за допомогою new.

*Різниця*:
Стек — менший, працює швидше, очищається автоматично при виході з методу.

Купа — більша, очищується збирачем сміття (Garbage Collector).



---

***№3. Розташування змінних та масивів у пам’яті***

Змінна може бути у стеку (якщо це локальна змінна) або в об’єкті у купі (якщо це поле об’єкта).

Масив завжди розташовується у купі, бо створюється через new.

Посилання на масив (тобто змінна, що зберігає адресу масиву) може бути у стеку або в полі об’єкта у купі.


---




***№4. Чим посилання на масив відрізняється від самого масиву?***

Посилання — це змінна, що містить адресу масиву в пам’яті.

Масив — це об’єкт, який зберігає елементи.
Посилання може бути:

у стеку (як локальна змінна),

у купі (як поле об’єкта),

або в іншому масиві (масив посилань).


---




***№5. Якщо масив має 10 комірок, які індекси мають перша та остання комірки?***

Перша: 0

Остання: 9 (тобто length - 1)



---

***№6. Що буде, якщо звернутися до неіснуючої комірки у масиві?***

Виникне помилка ArrayIndexOutOfBoundsException, і програма аварійно завершиться.



---

***№7. Ініціалізація нового масиву без явних значень***

При створенні нового масиву без ініціалізації всі його елементи ініціалізуються значеннями за замовчуванням, а не випадковими.

| *Тип*       | *Значення за замовчуванням* |
|:--------    | ---------------------------: |
|int, long, short, byte | 0 |
double, float | 0.0 |
boolean	| false |
char	|  '\u0000' |
посилальний тип (наприклад, String)	| null |


---

***№8. Як дізнатися номер першої та останньої комірки масиву, якщо відомо лише посилання на нього?***

Перша комірка має індекс 0.

Остання комірка має індекс array.length - 1.

---



***№9. Як змінити розмір масиву?***

Масиви в Java мають фіксований розмір. Його не можна змінити напряму.
Але можна створити новий масив більшого або меншого розміру й скопіювати дані
(або використовувати ArrayList, який змінює розмір динамічно).


---



***№10. Що відбувається з масивом при копіюванні посилання на нього?***

Посилання копіюється, але об’єкт залишається тим самим.
Тобто зміни через одну змінну видно й через іншу:

` ` `
int[] a = {1,2,3};
int[] b = a;
b[0] = 99; // тепер a[0] також = 99
` ` `

---

***№11. Що відбувається з масивом при втраті посилання на нього?***

Якщо на масив більше немає жодного посилання, Масив стає недосяжним, і збирач сміття (Garbage Collector) згодом його видаляє з пам’яті.



---




***№12. Чим відрізняються конструкції for та for-each при роботі з масивами?***

for дозволяє отримувати доступ до індексів, змінювати елементи, обходити частину масиву.

for-each лише читає значення (без прямого доступу до індексів), простіший і безпечніший.

Переваги for-each: коротший синтаксис, менше шансів на помилку.
Недоліки: не можна змінити елемент напряму та не видно індексу.




---

***№13. Чи можна у масив double[] записати значення int? Чи можна у масив int[] записати значення double?***

Так, бо int автоматично перетворюється в double (ширше перетворення

` ` `
double[] arr = {1, 2, 3}; // компілюється
` ` `
Але навпаки — не можна
` ` `
int[] arr = {1.5, 2.5}; //  Помилка компіляції
` ` `




---
